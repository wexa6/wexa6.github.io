---
title: "07CTF – Beta Bet Challenge"
date: 2025-09-14
categories: [CTFs, 07CTF]
tags: [crypto]
hidden: true
---

## Challenge Details:
-   Name: Beta Bet
-   Category: Crypto

**The challenge provides two files:**
-   `chall.py`: A Python script containing the encryption logic.
-   `out.txt`: A file containing 113 lines of encrypted text, each line being a potential flag.

* * * * *
## Challenge description
<p style="font-size:14px;">
Dear Alice,

It has been many moons since we last managed to talk in plain English. Hopefully my messenger has delivered to you this letter in-person, else assume we are compromised.

Last week I was glad to receive your latest letter, and to see that your "multi Czar" code is coming along nicely. So far I have been unable to decipher it, which bodes well for the security of our future messages - but does feel a little frustrating. Rather ingenious, although I do fear it is vulnerable in some way I can't quite elucidate yet.
</p>
* * * * *
## Solution

Looking at `chall.py`, we can see the core logic. The script takes the middle part of the flag, `FLAG[6:-1]`, and encrypts it 113 times. Each time, it generates a *new random key* of the same length as the plaintext.
```python
# chall.py
import secrets
from secret import FLAG

alphabet = "bcdefghijklmnopqrstuvwxyz"

# ... (random_key function)

def encrypt(m):
    key = random_key(m)[0 : len(m)]
    ct = []
    for i in range(len(m)):
        x = (ord(m[i]) + ord(key[i])) % 26
        x += ord("a")
        ct.append(chr(x))
    return "".join(ct)

# ... (main block)
```

The output in `out.txt` confirms this, with each line starting with `07CTF{` and ending with `}`
```
07CTF{gprthjioptsxvccfzifjtipukxcynlbpggwadpjyylfshhu}
07CTF{axlefypzdawwyhpnhmusncgedysgrkxnirbqkvwjerdvubr}
07CTF{yvubzffhfprmdpidgqjpxyjunnobbytjocxzppdropuijoa}
07CTF{hidvfgpazkngkbtutjscgrpuvgpniqimqnmqiogmsogzysr}
07CTF{xsldtyqicuciwonauhxwhhzxwvoznftxivysuqynbtlfnhg}
...
```
### The Vulnerability:
There are two crucial weaknesses working together:

1.  **The Key Alphabet**: The key is generated using characters from `alphabet = "bcdefghijklmnopqrstuvwxyz"`. This alphabet is *missing the letter 'a'*.
2.  **The Encryption Math**: The cipher uses the raw ASCII values of the characters (`ord()`) before the modulo, which is non-standard for a Vigenère cipher.

By converting characters to their 0-25 numeric values (a=0, b=1, etc.), we can derive the precise encryption formula:

`C′ = (P′+ K′+12) % 26`

*(Where C', P', and K' are the numeric values of the ciphertext, plaintext, and key characters, respectively.)*

Since the key alphabet excludes `'a'`, the key's numeric value, `K'`, can be any number from `1 to 25`, but it can never be `0`. This is the flaw we will exploit.
* * * * *
### Exploitation Strategy & Script:

Our script will iterate through each character position of the flag. For each position, it tries every letter from `'a'` to `'z'` as a potential plaintext character. If a guess, combined with one of the *113 known ciphertexts*, results in a hypothetical key value of `0`, that guess is proven incorrect and is discarded.

After checking all 113 ciphertexts, the remaining possible character(s) are the solution for that position.

```python
import string

# Read all ciphertexts from the output file
with open('out.txt', 'r') as f:
    lines = f.readlines()
ciphertexts = [line.strip()[6:-1] for line in lines]

pt_len = len(ciphertexts[0])
plaintext = ""
K_prime_forbidden = 0
offset = 12 

for i in range(pt_len):
    possible_pt_chars = []
    
    # Guess every possible lowercase letter for the current position
    for p_guess_char in string.ascii_lowercase:
        p_guess_val_0_25 = ord(p_guess_char) - ord('a')
        
        is_possible = True
        # Check our guess against all known ciphertext characters for this position
        for ct_char in [ct[i] for ct in ciphertexts]:
            c_val_0_25 = ord(ct_char) - ord('a')
            
            # Calculate what the key value would have had to be
            hypothetical_K_prime = (c_val_0_25 - p_guess_val_0_25 - offset) % 26
            
            # If it's the forbidden value, our guess is wrong
            if hypothetical_K_prime == K_prime_forbidden:
                is_possible = False
                break
        
        if is_possible:
            possible_pt_chars.append(p_guess_char)
            
    # We expect only one character to be possible
    if len(possible_pt_chars) == 1:
        plaintext += possible_pt_chars[0]
    else:
        # Handle ambiguities if they arise (unlikely with 113 samples)
        plaintext += f"[{''.join(possible_pt_chars)}]"
        
# Assemble and print the final flag
full_flag = f"07CTF{plaintext}"
print(full_flag)
```
* * * * *
## Flag
Running the script doesn't give us the full flag immediately. Instead, it produces a result with several ambiguities:
```
$ python solve.py
07CTF{ithought[alm]earn[ai]ngf[nr]omen[ik]gmawouldmakeitm[op]re[is]e[ce]ur[ez]}
```
This happens because, by pure chance, the specific key characters needed to rule out every single wrong guess didn't appear in the 113 samples for those positions. This leaves us with a simple word puzzle to solve.

The final step is to use linguistic context to resolve the bracketed options and form a coherent English sentence.

`ithought[alm]earn[ai]ng...` resolves to learning.
-   `[alm]` must be l.
-   `[ai]` must be i.

`...f[nr]om en[ik]gma...` resolves to from enigma.
-   `[nr]` must be r.
-   `[ik]` must be i. (A clear reference to the Enigma machine).

`...m[op]re [is]e[ce]ur[ez]}` resolves to more secure.
-   `[op]` must be o.
-   `[is]` must be s.
-   `[ce]` must be c.
-   `[ez]` must be e.

*07CTF{ithoughtlearningfromenigmawouldmakeitmoresecure}*

[⬅ Back to 07CTF Writeups](/posts/07CTF-writeups/)
